### 题目：
给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

示例 1:

输入: [3,2,3]
输出: 3

### 解析1：
排序后众数如果存在肯定是中间那个数，所以先排序然后直接输出中间那个数。

|  |复杂度|大小|百分比|
|--|--|--|--|   
|时间|$O(nlogn)$|288 ms|18.18%|
|空间|$O(1)$|13.1 MB|40.31%|

```python
class Solution(object):
    def majorityElement(self, nums):
        return sorted(nums)[(len(nums)-1)//2]      
```

### 解析2：
哈希表保存每个数出现的次数，然后判断出现次数是否超过一半。确认是否一定存在众数，如果不存在的话返回什么。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|212 ms|44.90%|
|空间|$O(1)$|14.4 MB|5.04%|

```python
class Solution(object):
    def majorityElement(self, nums):
        num_cnt = {}
        for i in range(len(nums)):
            num_cnt[nums[i]] = num_cnt.get(nums[i], 0)+1
        
        for key,value in num_cnt.items():
            if value > len(nums)//2:
                return key
```

### 解析3：
函数库实现，Python就要足够骚。思路和上述一样。竟然不如自己实现的快。看来还是不要用库。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|332 ms|9.2%|
|空间|$O(1)$|14.4 MB|5.04%|

```python
class Solution:
    def majorityElement(self, nums):
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)
```

### 解析4：
摩尔投票法，设置两个变量candiate和count如果数字与之前的candiate相同则count+1，否则-1.count变成0以后更新candiate然后count变成1.

```python
class Solution:
    def majorityElement(self, nums):
        count = 0
        candidate = None

        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)

        return candidate
```